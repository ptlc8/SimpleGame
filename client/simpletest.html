<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<!--<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />-->
		<title>SG !</title>
		<script src='phaser.js'></script>
		<style type="text/css">
		html, body {height: 100%; width: 100%; margin: 0; padding: 0; text-align: center;}
		span.display {color: white; text-shadow: 1px 1px 0 #000,	-1px 1px 0 #000,	1px -1px 0 #000,	-1px -1px 0 #000,	0px 1px 0 #000,	0px -1px 0 #000,	-1px 0px 0 #000,	1px 0px 0 #000,	2px 2px 0 #000,	-2px 2px 0 #000,	2px -2px 0 #000,	-2px -2px 0 #000,	0px 2px 0 #000,	0px -2px 0 #000,	-2px 0px 0 #000,	2px 0px 0 #000,	1px 2px 0 #000,	-1px 2px 0 #000,	1px -2px 0 #000,	-1px -2px 0 #000,	2px 1px 0 #000,	-2px 1px 0 #000,	2px -1px 0 #000,	-2px -1px 0 #000; font-size: 2em;}
		#game-div {position: relative; margin: 0 auto;}
		#game-div:fullscreen {background-color: black;}
		#menu-div {position: absolute; pointer-events: none;}
		#menu-div * {pointer-events: auto; font-family: Elected Office, Arial}
		@media screen and (orientation: landscape) {#game-div, #game-div > canvas, #menu-div {height: 100vh; width: 133vh; font-size: 100vh}
													#game-div:fullscreen #menu-div {left: 50%; transform: translateX(-50%);}}
		@media screen and (orientation: portrait ) {#game-div, #game-div > canvas, #menu-div {width: 100vw; height: 75vw; font-size: 75vw}}
		@font-face {font-family: "Elected Office"; src: url("fonts/elected-office.regular.ttf");}
		@font-face {font-family: "Elected Office Outline"; src: url("fonts/elected-office.outline.ttf");}
		</style>
		<script src="menuUtils2.js"></script>
		<script src="prebuiltMaps.js"></script>
	</head>
	<body>
		<div id="eee">
			<div id="game-div">
				<!--canvas-->
				<div id="menu-div" style="background-color: black">
				<div id="first-menu">
					<span id="title" style="position:absolute;top: 18%;left: 0;font-size: 20%;color:white;width:100%;">Brawl Arena</span>
					<img src="assets/buttons/connect-server.png" onclick="printConnectServerMenu()" style="position:absolute;top: calc(60% + -64px);left: calc(50% + -64px);width: 128px;image-rendering: pixelated;height: 128px;">
				</div>
				<div id="connect-server-menu" style="display: none;">
					<input type="text" id="ip" placeholder="Adresse IP" onkeyup="if (event.keyCode == 13) connectServer()" style="position:absolute;top:48%;left:30.375%;width:calc(25% + -6px);height:calc(4% + -6px);border-width:2px">
					<img src="assets/buttons/connect-server.png" onclick="connectServer()" style="position:absolute;top:calc(50% + -32px);left:calc(65% + -32px);width:64px;height:64px;">
				</div>
				<div id="id-menu" style="display: none;">
					<img id="leave-server-button" src="assets/buttons/back.png" style="position:absolute;top: calc(10% + -32px);left: calc(10% + -32px);width:64px;height:64px;">
					<input type="text" id="pseudo" placeholder="Pseudo" onkeyup="if (event.keyCode == 13) sendPseudo()" style="position:absolute;top:48%;left:30.375%;width:calc(25% + -6px);height:calc(4% + -6px);border-width:2px">
					<img src="assets/buttons/valid.png" onclick="sendPseudo()" style="position:absolute;top:calc(50% + -20px);left:calc(65% + -32px);width:64px;height:40px;">
				</div>
				<div id="games-menu" style="display: none;">
					<input type="text" id="searchbar" placeholder="Rechercher des parties" onkeyup="if (event.keyCode == 13) searchGames();" style="position:absolute;top:8.333333333333334%;left:12.5%;width:calc(39.75% + -6px);height:calc(6.666666666666667% + -6px);border-width:2px">
					<img src="assets/buttons/search.png" onclick="searchGames();" style="position:absolute;top:calc(11.666666666666666% + -20px);left:calc(58% + -32px);width:64px;height:40px;">
					<div id="games" style="position:absolute;top:20%;left:12.5%;width:50%;height:66.66666666666667%;background-color:whitesmoke;overflow:auto;border-radius:5%"></div>
					<input type="text" id="creategame" placeholder="Nom de la partie à créer" onkeyup="if (event.keyCode == 13) createGame();" style="position:absolute;top:37.166666666666664%;left:68.75%;width:calc(25% + -6px);height:calc(6.666666666666667% + -6px);border-width:2px">
					<img src="assets/buttons/create-game.png" onclick="createGame();" style="position:absolute;top:calc(54.333333333333336% + -32px);left:calc(81.25% + -32px);width:64px;height:64px;">
					<span id="version" style="position:absolute;top:86.66666666666667%;left:12.5%;font-size:2%;color:whitesmoke;display:inline-block;width:50%;">Version du serveur : ???</span>
				</div>
				<div id="game-menu" style="display:none";>
					<img src="assets/buttons/back.png" onclick="leaveGame();" style="position:absolute;top:calc(10% + -32px);left:calc(10% + -32px);width:64px;height:64px;">
					<span id="gamename" style="position:absolute;top:6.666666666666667%;left:20.5%;font-size:10%;color:whitesmoke;display:inline-block;width:59%;"></span>
					<textarea id="chat" placeholder="Bienvenue dans cette nouvelle partie !" style="position:absolute;top:24%;left:12.5%;width:calc(50% + -6px);height:calc(47.666666666666664% + -6px); resize: none;border-width:1px" disabled></textarea>
					<input type="text" id="sendchat" placeholder="Envoyez un chat pour communiquer" onkeyup="if (event.keyCode == 13) sendChat();" style="position:absolute;top:76.66666666666667%;left:12.5%;width:calc(39.75% + -6px);height:calc(6.666666666666667% + -6px);border-width:2px">
					<img src="assets/buttons/send.png" onclick="sendChat()" style="position:absolute;top:calc(80% + -20px);left:calc(58% + -32px);width:64px;height:40px;">
					<textarea id="players" placeholder="" style="position:absolute;top:24%;left:68.75%;width:calc(18.75% + -6px);height:calc(31% + -6px); resize: none;border-width:1px" disabled></textarea>
					<canvas id="map" style="position:absolute;top:60%;left:68.75%;height:11.666666666666666%;width:18.75%;image-rendering:pixelated;" height="11" width="23"></canvas>
					<img src="assets/buttons/parameters.png" onclick="" style="position:absolute;top:calc(80% + -32px);left:calc(84% + -32px);width:64px;height:64px;">
				</div>
			</div>
		</div>
		<button onclick="switchFullscreen()">Plein écran</button>
		<button onclick="switchInputMode(); this.textContent=isTactile?'Mode clavier':'Mode tactile';">Mode tactile</button>
		<span style="font-family: Elected Office;"></span>
		<span style="font-family: Elected Office Outline;"></span>
		<script>

setDefaultAddContentDiv("#menu-div");
/*preloadImages(function() {addImage("multiplayer-button", "assets/buttons/connect-server.png", 50,50, printConnectServerMenu, true);},
		["assets/buttons/connect-server.png",
		"assets/buttons/valid.png",
		"assets/buttons/back.png",
		'assets/lum.png',
		'assets/joystick.png',
		'assets/joystick-back.png',
		'assets/special-button.png',
		//'assets/loaded.png', {frameWidth:128, framHeight: 128},
		'assets/buttons/create-game.png',
		'assets/buttons/search.png',
		'assets/buttons/confirm.png',
		'assets/buttons/send.png',
		'assets/buttons/parameters.png',
		'assets/buttons/connect-server.png',
		'assets/buttons/guerrier.png']);
	/*this.load.image('mage-button', 'assets/buttons/mage.png');
	this.load.image('golem-button', 'assets/buttons/golem.png');
	this.load.image('necromancien-button', 'assets/buttons/coming-soon.png');
	this.load.image('alchimiste-button', 'assets/buttons/coming-soon.png');
	this.load.image('random-button', 'assets/buttons/random.png');
	this.load.image('spectatorMenu', 'assets/buttons/connect-server.png');
	//...
	this.load.image('coup-fort-button', 'assets/buttons/coming-soon.png');
	this.load.image('fleche-empoisonnee-button', 'assets/buttons/fleche-empoisonnee.png');
	this.load.image('boule-de-feu-button', 'assets/buttons/boule-de-feu.png');
	this.load.image('boule-de-glace-button', 'assets/buttons/boule-de-glace.png');
	this.load.image('mer-de-flammes-button', 'assets/buttons/coming-soon.png');
	this.load.image('terre-glacee-button', 'assets/buttons/terre-glacee.png');
	//...
	
	//----map
	this.load.image('map','assets/map3.png');
	
	//----classes images
	this.load.image('guerrier', 'assets/classes/guerrier.png');
	this.load.image('guerrier-right', 'assets/classes/guerrier-right.png');
	this.load.image('guerrier-left', 'assets/classes/guerrier-left.png');
	this.load.image('archer', 'assets/classes/guerrier.png');
	this.load.image('archer-right', 'assets/classes/guerrier-right.png');
	this.load.image('archer-left', 'assets/classes/guerrier-left.png');
	this.load.image('assassin', 'assets/classes/guerrier.png');
	this.load.image('assassin-right', 'assets/classes/guerrier-right.png');
	this.load.image('assassin-left', 'assets/classes/guerrier-left.png');
	this.load.image('mage', 'assets/classes/mage.png');
	this.load.image('mage-right', 'assets/classes/mage.png');
	this.load.image('mage-left', 'assets/classes/mage.png');
	this.load.image('golem', 'assets/classes/golem.png');
	this.load.image('golem-right', 'assets/classes/golem.png');
	this.load.image('golem-left', 'assets/classes/golem.png');
	this.load.image('necromancien', 'assets/classes/guerrier.png');
	this.load.image('necromancien-right', 'assets/classes/guerrier-right.png');
	this.load.image('necromancien-left', 'assets/classes/guerrier-left.png');
	this.load.image('alchimiste', 'assets/classes/guerrier.png');
	this.load.image('alchimiste-right', 'assets/classes/guerrier-right.png');
	this.load.image('alchimiste-left', 'assets/classes/guerrier-left.png');
	
	//----armes
	this.load.image('arrow', 'assets/weapons/arrow.png');
	this.load.image('sword', 'assets/weapons/sword.png');
	this.load.image('dagger', 'assets/weapons/dagger.png');
	this.load.image('spell', 'assets/weapons/spell.png');
	this.load.image('punch', 'assets/weapons/punch.png');
	
	//----capacités
	this.load.image('slowness-area', 'assets/weapons/slowness-area.png');
	this.load.image('fireball', 'assets/weapons/fireball.png');
	this.load.image('iceball', 'assets/weapons/iceball.png');
	this.load.image('trap', 'assets/weapons/trap.png');
	this.load.image('trap-explode', 'assets/weapons/trap-explode.png');
	this.load.image('earthquake', 'assets/weapons/earthquake.png');
	this.load.image('flames-sea', 'assets/weapons/flames-sea.png');
	this.load.image('stone-wall', 'assets/stone-wall.png');
	this.load.image('shield', 'assets/weapons/shield.png');
	
	//----
	this.load.image('healthBar', 'assets/health-bar.png');
	this.load.image('energyBar', 'assets/energy-bar.png');
	this.load.image('specialBar', 'assets/special-bar.png');*/


var debug = false;
var isTactile = false;
var connection;
var ping;
var me = "";
var chat = [];
var players = [];
var isCreator = false;
var map = {"pattern":[[2,2,2,0,2,2,2,0,2,2,0,0,0,2,2,2,2],[2,2,2,0,0,2,2,0,2,0,2,2,2,0,2,2,2],[2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,2,2],[2,2,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2],[2,2,2,0,2,2,2,0,2,2,0,0,0,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,2,2,2,0,2,2,0,0,0,2,2,0,0,0,0,2],[0,0,2,0,0,2,0,2,2,2,0,2,0,2,2,2,0],[0,2,0,2,0,2,0,0,0,0,0,2,0,0,0,0,2],[0,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2],[0,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2]],"teams":[]};
var isBindingKeys = false;
var keys = {up: false, right: false, down: false, left: false};
var lastMove = {move: false, direction: 0};
var frags;
var myEntityId = -1;
var entities;
var isPlaying = false;
var healthMax = 0;
var health = 0;
var energyMax = 0;
var energy = 0;
var special = 0
var specialMax = 0;
var isSpectator = false;
var teamMates = [];
var followingentityid;

var selectedClassName = "random";
var selectedCapacityN = -1;
var runSound;
var teams = [];
var nextIsSpecial = false;

//new Phaser.Game(config);

function preload() {
	
	game = this;
	
	//----background
	
	
	//----sons
	this.load.audio('run', 'assets/audio/run.mp3');
}

function create() {
	
	lums = this.physics.add.group();
	for (var i = 0; i < 22; i++)
		lums.create(Phaser.Math.Between(0, 800), Phaser.Math.Between(0, 800), 'lum');
	
	setDefaultAddContentDiv("#menu-div");
	
	this.anims.create({key: 'special-loaded', frames: this.anims.generateFrameNumbers('special-loaded'), repeat: -1});
	
	multiplayerButton = this.add.sprite(400, 350, 'connect-server').setScale(2).setInteractive().on('pointerdown', printConnectServerMenu);
	connectServerButton = this.add.sprite(525, 310, 'connect-server').setInteractive().on('pointerdown', connectServer);
		connectServerButton.visible = false;
	confirmPseudo = this.add.sprite(525, 310, 'confirm').setInteractive().on('pointerdown', sendPseudo); confirmPseudo.visible = false;
	leaveServerButton = this.add.sprite(100+32, 50+32, 'back').setInteractive().on('pointerdown', leaveServer); leaveServerButton.visible = false;
	searchGamesButton = this.add.sprite(468, 70, 'search').setInteractive().on('pointerdown', searchGames); searchGamesButton.visible = false;
	createGameButton = this.add.sprite(650, 313, 'create-game').setInteractive().on('pointerdown', createGame); createGameButton.visible = false;
	leaveGameButton = this.add.sprite(100+32, 50+32, 'back').setInteractive().on('pointerdown', leaveGame); leaveGameButton.visible = false;
	sendChatButton = this.add.sprite(500-32, 500-20, 'send').setInteractive().on('pointerdown', sendChat); sendChatButton.visible = false;
	configGameButton = this.add.sprite(700-32, 500-20, 'config').setInteractive().on('pointerdown', configGame);
		configGameButton.visible = false;
	backToGameMenuButton = this.add.sprite(100+32, 50+32, 'back').setInteractive().on('pointerdown', backToGameMenu);
		backToGameMenuButton.visible = false;
	sendMapAndTeamsButton = this.add.sprite(500+30+32, 50+64+30+20, 'send').setInteractive().on('pointerdown', sendMapAndTeams);
		sendMapAndTeamsButton.visible = false;
	startGameButton = this.add.sprite(500+30+32, 50+64+30+40+30+20, 'start').setInteractive().on('pointerdown', startGame);
		startGameButton.visible = false;
	soloButton = this.add.sprite(200,300,'solo').setInteractive().on('pointerdown', printSoloMenu);
		/**/soloButton.visible = false;
	spectatorMenuButton = this.add.sprite(200,300,'spectatorMenu').setInteractive().on('pointerdown',printTeamMateSpectatingMenu);
		spectatorMenuButton.visible = false;
		spectatorMenuButton.setScrollFactor(0);
	returnToGameMenuButton = this.add.sprite(400,400,'back').setInteractive().on('pointerdown',returnToGameMenu);
		returnToGameMenuButton.visible = false;
		spectatorMenuButton.setScrollFactor(0);
		
		//------bouton choix de classe
	warriorClassChoose = this.add.sprite(75, 75, 'guerrier-button').setInteractive().on('pointerdown', function() {getClassStats("guerrier");});
		warriorClassChoose.visible = false;
	archerClassChoose = this.add.sprite(225, 75, 'archer-button').setInteractive().on('pointerdown', function() {getClassStats("archer");});
		archerClassChoose.visible = false;
	golemClassChoose = this.add.sprite(75, 225, 'golem-button').setInteractive().on('pointerdown', function() {getClassStats("golem");});
		golemClassChoose.visible = false;
	mageClassChoose = this.add.sprite(225, 225, 'mage-button').setInteractive().on('pointerdown', function() {getClassStats("mage");});
		mageClassChoose.visible = false;
	assassinClassChoose = this.add.sprite(75, 375, 'assassin-button').setInteractive().on('pointerdown', function() {getClassStats("assassin");});
		assassinClassChoose.visible = false;
	invocateurClassChoose = this.add.sprite(225, 375, 'necromancien-button').setInteractive().on('pointerdown', function() {getClassStats("necromancien");});
		invocateurClassChoose.visible = false;
	randomClassChoose = this.add.sprite(75, 525, 'random-button').setInteractive().on('pointerdown', function() {getClassStats("random");});
		randomClassChoose.visible = false;
	alchimisteClassChoose = this.add.sprite(225, 525, 'alchimiste-button').setInteractive().on('pointerdown', function() {getClassStats("alchimiste");});
		alchimisteClassChoose.visible = false;
	previewClass = this.add.image(475, 128+32, "guerrier").setScale(4).setVisible(false);
	classStats = this.add.text(300+11, 96*3+11, "-STATS-").setColor("#eeeeee").setWordWrapWidth(328).setVisible(false);
	capacityStats = this.add.text(300+11, 407, "-CAPA STATS-").setColor("#eeeeee").setWordWrapWidth(328).setVisible(false);
	chooseClassButton = this.add.sprite(475, 600-64-11, "confirm").setInteractive().on('pointerdown', function() {chooseClass(selectedClassName, selectedCapacityN);});
		chooseClassButton.visible = false;
	
	capacity0Button = this.add.image(725, 75, 'coup-fort-button').setInteractive().on('pointerdown', function() {printCapacityStats(0); selectedCapacityN=0;}).setVisible(false);
	capacity1Button = this.add.image(725, 225, 'coup-fort-button').setInteractive().on('pointerdown', function() {printCapacityStats(1); selectedCapacityN=1;}).setVisible(false);
	capacity2Button = this.add.image(725, 375, 'coup-fort-button').setInteractive().on('pointerdown', function() {printCapacityStats(2); selectedCapacityN=2;}).setVisible(false);
	capacity3Button = this.add.image(725, 525, 'coup-fort-button').setInteractive().on('pointerdown', function() {printCapacityStats(3); selectedCapacityN=3;}).setVisible(false);
	
	this.input.keyboard.on('keydown', onKeyDown);
	this.input.keyboard.on('keyup', onKeyUp);
	
	this.input.on('pointerdown', onClick, this);
	this.input.on('pointerup', unClick, this);
	this.input.mouse.disableContextMenu();
	
	frags = this.physics.add.staticGroup();
	
	entities = this.add.group();
	
	camera = this.cameras.main;
	camera.zoomTo(1); // pour éviter un bug
	
	title = this.add.text(400, 160, "Brawl Arena").setOrigin(0.5).setFontSize(96).setStroke("black", 16).setShadow(2,2,"#333333",2,true,true).setFontFamily("Elected Office");
	//addText("title", 100, 96, 10, "SimpleGame", 600, "white");
	
	game.input.addPointer(2);
	joystick = game.add.image(100, 500, "joystick").setDepth(Infinity).setScrollFactor(0).setVisible(isTactile);
	joystickBack = game.add.image(100, 500, "joystick-back").setScale(2).setAlpha(0.25).setDepth(Infinity).setScrollFactor(0).setVisible(isTactile);
	specialButton = game.add.image(700, 500, "special-button").setDepth(Infinity).setScrollFactor(0).setVisible(isTactile).setInteractive().on('pointerdown', onSpecialButton);
	specialLoaded = game.add.sprite(700, 500, "special-loaded").setDepth(Infinity).setScrollFactor(0).setVisible(isTactile && nextIsSpecial);
	specialLoaded.anims.play('special-loaded');
	tactileGUI = game.add.container(0,0,[joystick, joystickBack, specialButton, specialLoaded]).setDepth(Infinity);
	
}

function update() {
	
	lums.children.iterate(function(lum) {
		lum.setVelocityX(Math.max(-10, Math.min(10, lum.body.velocity.x+Phaser.Math.Between(-1, 1))));
		lum.setVelocityY(Math.max(-10, Math.min(10, lum.body.velocity.y+Phaser.Math.Between(-1, 1))));
	});
	
	if (isPlaying) {
		connection.send("getentities");
		if (energy < energyMax)
			refreshEnergy(energy + 1);
		if (special < specialMax)
			refreshSpecial(special + 1);
	}
	
	if (joystick.followCursor) {
		let x = joystick.followCursor.x;
		let y = joystick.followCursor.y;
		let newX = x < joystickBack.x ? Math.max(x, Math.cos(Math.atan2(y-joystickBack.y, x-joystickBack.x))*64+joystickBack.x)
												: Math.min(x, Math.cos(Math.atan2(y-joystickBack.y, x-joystickBack.x))*64+joystickBack.x);
		let newY = y < joystickBack.y ? Math.max(y, Math.sin(Math.atan2(y-joystickBack.y, x-joystickBack.x))*64+joystickBack.y)
												: Math.min(y, Math.sin(Math.atan2(y-joystickBack.y, x-joystickBack.x))*64+joystickBack.y);
		if (joystick.x != newX || joystick.xy != newY) {
			joystick.setPosition(newX, newY);
			if (isBindingKeys)
				sendMove(getAngleInRadians({x:newX-joystickBack.x,y:newY-joystickBack.y}));
		}
	}
	
	if (isSpectator){
		connection.send("getentities");
	}
	
	if (!isSpectator) {
		if (camera._follow == null && entities.children.get("id", myEntityId) !== undefined)
			camera.startFollow(entities.children.get("id", myEntityId), true);
		
	}
	
	if (isSpectator){
		if (entities.children.get("id",followingentityid) !== undefined)
			camera.startFollow(entities.children.get("id",followingentityid), true);
	}
	
}

function printSoloMenu(){
	remove("title");
	multiplayerButton.visible = false;
	soloButton.visible = false ;
	//soon ?
}

function onMessage(command, arg) {
	switch (command) {
		case "pong":
			ping = Date.now() - parseInt(arg);
			console.log(`Ping : ${ping}ms`);
			break;
		case "youreloggedin":
		case "youreregistered":
			me = arg;
			hideIdMenu();
			printGamesMenu();
			break;
		case "playernamealreadyused":
			displayError("pseudo", "Ce pseudonyme est déjà utilisé");
			break;
		case "youare":
			displayError("pseudo", "Aucun pseudonyme renseigné");
			break;
		case "searchgameresults":
			var games = JSON.parse(arg);
			var gamesEls = [];
			for (var i = 0; i < games.length; i++)
				gamesEls.push(addDiv("game"+i, 0, i*12, 100, 12, [addText("game"+i+"name", 4,30, 3, games[i], 69, "black", true), addButton("game"+i+"joinbutton", 76, 10, 20, 80, function(name) {joinGame(name);}, [games[i]], "rejoindre", 3, "limegreen", true)], undefined, true));
			setDivContent("games", gamesEls);
			break;
		case "gamecreated":	
		case "gamejoined":
			hideGamesMenu();
			printGameMenu(arg);
			break;
		case  "gamenamealreadyused":
			displayError("creategame", "Ce nom de partie est déjà utilisé");
			break;
		case "gameneedaname":
			displayError("creategame", "Aucun nom de partie renseigné");
			break;
		case "gameisplaying":
			displayError("games", "Cette partie est déjà lancée");
			break;
		case "gamedoesntexist":
			displayError("games", "Cette partie n'existe plus");
			break;
		case "needagamename":
			displayError("games", "Erreur de dèv");
			break;
		case "gameleaved":
			hideGameMenu();
			printGamesMenu();
			break;
		case "chat":
			msgs = JSON.parse(arg);
			chat = [];
			for (var i = 0; i < msgs.length; i++)
				chat.push("<" + msgs[i].sender + "> " + msgs[i].content);
			addChat();
			break;
		case "memberleave":
			addChat(arg + " a quitté la partie");
			for (var i = 0; i < players.length; i++){ 
				if (players[i].name == arg) {
					players.splice(i, 1); 
					i--;
				}
			}
			refreshPlayers();
			break;
		case "memberjoin":
			addChat(arg + " a rejoint la partie");
			players.push({name:arg});
			refreshPlayers();
			break;
		case "creatoris":
			if (isCreator = me == arg)
				configGameButton.visible = true;
			else
				configGameButton.visible = false;
			break;
		case "players":
			players = JSON.parse(arg);
			refreshPlayers();
			break
		case "newchat":
			var message = JSON.parse(arg);
			addChat("<" + message.sender + "> " + message.content);
			break;
		case "messagereceived":
			//do nothing
			break;
		case "needmessagecontent":
			displayError("sendchat", "Le message ne peut être vide");
			break;
		case "mapandteams":
			var mapandteams = JSON.parse(arg);
			if (mapandteams != null) map = mapandteams;
			addChat("La carte de jeu et les équipes ont été mises à jour");
			refreshMapPreview("map", map.pattern);
			break;
		case "map":
			var map_ = JSON.parse(arg);
			if (map_ != null) map.pattern = map_.pattern;
			addChat("La carte de jeu a été mise à jour");
			refreshMapPreview("map", map.pattern); 
			break;
		case "mapandteamssetted":
			display("Carte de jeu et équipes correctement modifiées");
			break;
		case "youarentcreator":
			display("Vous n'êtes pas le créateur de cette partie");
			break;
		case "invalidmapandteams":
			displayError("mapJson", "Le nombre de points d'apparition de correspond pas au nombre d'équipes ou est nul");
			break;
		case "needjsonmapandteams":
			displayError("mapJson", "Une erreur de syntaxe JSON est présente");
			break;
		case "needmapandteams":
			displayError("mapJson", "Aucune carte de jeu n'a été renseignée");
			break;
		case "gamestarted":
			hideConfigGame();
			hideGameMenu();
			printTeamMenu();
			break;
		case "needmap":
			display("Aucune carte de jeu n'a été renseignée");
			break;
		case "needmoreplayers":
			display("Il y a plus d'équipes que de joueurs, actuellement : " + arg);
			break;
		case "playerswithteams":
			
			break;
		case "teamjoined":
			addText("waiting", 100, 520, 5, "En attente des autres joueurs...", 600, "whitesmoke");
			break;
		case "needexistingteamname":
			// do nothing 'cause can't happen
			break;
		case "needteamname":
			// do nothing 'cause can't happen
			break;
		case "teamleaved":
			remove("waiting");
			break;
		case "teamscompleted":
			hideTeamMenu();
			printClassMenu();
			break;
		case "classsetted":
			
			break;
		case "capacitysetted":
			if (classStats.visible)
				addText("waiting", 100, 520, 5, "En attente des autres joueurs...", 600	, "whitesmoke");
			break;
		case "capacityunsetted":
			remove("waiting");
			break;
		case "classeschoosen":
			hideClassMenu();
			break;
		case "playingin":
			display(arg, 4, 1000, true);
			if (arg == "3")
				preStart();
			break;
		case "letsplay":
			display("C'est parti !", 5, 2000, true);
			start();
			break;
		case "newbrawl":
			display("Rebrawl !", 5, 2000, true);
			rebrawl();
			break;
		case "yourentityid":
			camera._follow = null;
			myEntityId = JSON.parse(arg);
			break;
		case "entities":
			var entitiesFromServer = JSON.parse(arg);
			 if (entitiesFromServer != null) refreshEntities(entitiesFromServer);
			break;
		case "unknowcommand":
			console.log("Dèvs ! On envoie des commandes qui n'existe pas encore : " + arg);
			break;
		case "health":
			refreshHealth(parseInt(arg));
			break;
		case "energy":
			refreshEnergy(parseInt(arg));
			break;
		case "special":
			refreshSpecial(parseInt(arg));
			break;
		case "ath":
			var args = arg.split(" ");
			healthMax = parseInt(args[1]);
			refreshHealth(health = parseInt(args[0]));
			energyMax = parseInt(args[3]);
			refreshEnergy (energy = parseInt(args[2]));
			specialMax = parseInt(args[5]);
			refreshSpecial(special = parseInt(args[4]));
			break;
		case "kill":
			var kill = JSON.parse(arg);
			
			break;
		case "youredead":
			isBindingKeys = false;
			isPlaying = false;
			isSpectator = true;
			tactileGUI.setVisible(false);
			hideATH()
			connection.send("getteammateswithclasses");
			break;
		case "teammateswithclasses":
			teamMates = JSON.parse(arg);
			printTeamMateSpectatingMenu();
			break;
		case "followingentityid":
			followingentityid = JSON.parse(arg);
			camera._follow = null;
			break;
		case "classstats":
			printClassStats(JSON.parse(arg));
			break;
		case "cantfollow":
			printTeamMateSpectatingMenu();
			displayError("teammates","Impossible de suivre se joueur")
			break;
		case "end":
			if (arg == "draw"){
				addText("result",100,275,8,"Egalité :O",600,"white");
			}
			else{
				var winners = JSON.parse(arg);
				addText("result",100,275,8,`Victoire de l'équipe ${winners}`,600,"white");
			}
			returnToGameMenuButton.visible = true;
			break;
		case "version":
			setText("version", `Version du serveur : ${arg}`);
			break;
		case "effect":
			onEffect(JSON.parse(arg));
			break;
		case "wave":
			display(`Vague ${arg} !`, 4, 2000, true);
			break;
		case "teams":
			teams = JSON.parse(arg);
			if (exists("tab"))
				printTabMenu();
			break;
		default:
			console.log("Dèvs ! Ya une commande non prise en compte : " + command);
			break;
	}
}



//----Menu de connection

function printConnectServerMenu() {
	setVisible("first-menu", false);
	setVisible("connect-server-menu", true);
	get("ip").focus();
}

function connectServer() {
	if (getText("ip") == "") {
		displayError("ip", "Aucune adresse IP renseignée");
		return;
	}
	if (connection) {
		connection.onerror = undefined;
		connection.close();
	}
	connection = new WebSocket('ws://'+getText("ip"));
	connection.onopen = function () {
		setVisible("connect-server-menu", false);
		console.log('Connected!');
		connection.send('ping');
		printIdMenu();
		connection.onclose = function() {
			display("Connexion avec le serveur perdue");
		}
	};
	connection.onerror = function (error) {
		console.log(error);
		displayError("ip", "Erreur de connexion au serveur : " + error.target.url);
	};
	connection.onmessage = function (message) {
		if (debug) console.log('Server: ' + message.data);
		onMessage(message.data.split(" ")[0], message.data.replace(/\S* /, ""));
	};
}



//----Menu d'identification

function printIdMenu() {
	setVisible("id-menu", true);
	get("pseudo").focus();
}

function sendPseudo() {
	connection.send("iam "+getTextFieldText("pseudo"));
}

function hideIdMenu() {
	setVisible("id-menu", false);
}

function leaveServer() {
	setVisible("id-menu", false);
	setVisible("games-menu", false);
	connection.onclose = function(){};
	connection.close();
	setVisible("connect-server-menu", true);
}



//----Menu principal

function printGamesMenu() {
	setVisible("games-menu", true);
	get("searchbar").focus();
	searchGames();
	getVersion();
}

function searchGames() {
	connection.send("searchgame " + getText("searchbar"));
}

function joinGame(name) {
	connection.send("joingame " + name)
}

function createGame() {
	connection.send("creategame " + getText("creategame"));
}

function getVersion() {
	connection.send("getversion");
}

function hideGamesMenu() {
	setVisible("games-menu", false)
}



//----Menu d'une partie

function printGameMenu(name) {
	setVisible("game-menu", true);
	setText("gamename", name);
	connection.send("getchat");
	connection.send("getplayers");
	connection.send("getmapandteams");
	connection.send("whoiscreator");
}

function leaveGame() {
	connection.send("leavegame");
}

function addChat(line) {
	if (line) chat.push(line);
	var text = chat.length > 0 ? chat[0] : "";
	for (var i = 1; i < chat.length; i++)
		text += "\n" + chat[i];
	setText("chat", text);
}

function refreshPlayers() {
	var text = players.length > 0 ? players[0].name : "";
	for (var i = 1; i < players.length; i++)
		text += "\n" + players[i].name;
	setText("players", text);
}

function sendChat() {
	connection.send("sendchat " + getText("sendchat"));
	setText("sendchat", "");
}

function hideGameMenu(toConfig) {
	leaveGameButton.visible = false;
	if (!toConfig) {
		remove("gamename");
		remove("map");
	}
	remove("chat");
	remove("sendchat");
	sendChatButton.visible = false;
	remove("players");
	configGameButton.visible = false;
}

// apres la fin d'une partie
function returnToGameMenu(){
	printGameMenu();
	remove("result");
}



//----Menu de configuration d'une partie

function configGame() {
	hideGameMenu(true);
	backToGameMenuButton.visible = true;
	addTextArea("mapJson", 100, 50+64+30, 400, 200, "Carte de jeu et équipes au format JSON", false, sendMapAndTeams);
	sendMapAndTeamsButton.visible = true;
	startGameButton.visible = true;
}

function sendMapAndTeams() {
	connection.send("setmapandteams " + getText("mapJson"));
}

function startGame() {
	connection.send("start");
}

function backToGameMenu() {
	hideConfigGame(true);
	printGameMenu();
}

function hideConfigGame(toGameMenu) {
	backToGameMenuButton.visible = false;
	if (!toGameMenu) {
		remove("gamename");
		remove("map");
	}
	remove("mapJson");
	sendMapAndTeamsButton.visible = false;
	startGameButton.visible = false;
}



//----Menu de choix d'équipe

function printTeamMenu() {
	var teamsEls = [];
	var w = (100-2*(map.teams.length-1))/map.teams.length;
	var h = 350;
	for (var i = 0; i < map.teams.length; i++) {
		teamsEls.push(addDiv("team"+i, (w+2)*i, 0, w, 100, [addText("team"+i+"name", 5, 5, 3, map.teams[i], 90, "black", true), addTextArea("team"+i+"members", 0, 15, 100, 55, "Aucun joueur", true, undefined, true), addButton("team"+i+"join", 0, 75, 100, 20, joinTeam, [map.teams[i]], "Rejoindre", 3, "limegreen", true)], "whitesmoke", true));
	}
	addDiv("teams", 50, 150, 700, h, teamsEls);
}

function joinTeam(name) {
	connection.send("jointeam " + name);
}

function hideTeamMenu() {
	remove("teams");
	remove("waiting");
}



//----Menu de choix de classe

function printClassMenu() {
	warriorClassChoose.visible = true;
	archerClassChoose.visible = true;
	golemClassChoose.visible = true;
	mageClassChoose.visible = true;
	assassinClassChoose.visible = true;
	invocateurClassChoose.visible = true;
	randomClassChoose.visible = true;
	alchimisteClassChoose.visible = true;
	previewClass.visible = true;
	classStats.visible = true;
	capacityStats.visible = true;
}

function getClassStats(className) {
	connection.send("getclassstats " + className);
	previewClass.visible = true;
	classStats.visible = true;
	selectedClassName = className;
	capacityStats.setText("");
	let showCapa = className != "random";
	capacity0Button.visible = showCapa;
	capacity1Button.visible = showCapa;
	capacity2Button.visible = showCapa;
	capacity3Button.visible = showCapa;
	chooseClassButton.visible = !showCapa;
}

function printClassStats(stats) {
	previewClass.setTexture(stats.imageName);
	classStats.setText([stats.name.toUpperCase(), "Vie : "+stats.health, "Vitesse : "+stats.speed, "Dégâts : "+stats.damage, "Energie : "+stats.energy, "Coût d'une attaque : "+stats.attackCost]);
	capacity0Button.setTexture(stats.capacities[0].imageName+"-button");
	capacity1Button.setTexture(stats.capacities[1].imageName+"-button");
	capacity2Button.setTexture(stats.capacities[2].imageName+"-button");
	capacity3Button.setTexture(stats.capacities[3].imageName+"-button");
	capacities = stats.capacities;
}

function printCapacityStats(n) {
	capacityStats.setText([capacities[n].name.toUpperCase(), capacities[n].description, "Coût : "+capacities[n].cost]);
	chooseClassButton.visible = true;
}

function chooseClass(className, capacityN) {
	className = className || "random";
	connection.send("setclass " + className);
	connection.send("setcapacity " + (className=="random" ? 0 : capacityN));
}

function hideClassMenu() {
	warriorClassChoose.visible = false;
	archerClassChoose.visible = false;
	golemClassChoose.visible = false;
	mageClassChoose.visible = false;
	assassinClassChoose.visible = false;
	invocateurClassChoose.visible = false;
	randomClassChoose.visible = false;
	alchimisteClassChoose.visible = false;
	previewClass.visible = false;
	classStats.visible = false;
	capacityStats.visible = false;
	chooseClassButton.visible = false;
	capacityStats.visible = false;
	capacity0Button.visible = false;
	capacity1Button.visible = false;
	capacity2Button.visible = false;
	capacity3Button.visible = false;
	remove("waiting");
}



//-------affichage d'une partie(jeu)

function preStart() {
	displayMap(map.pattern);
	connection.send("getmyentityid");
	connection.send("getentities");
	healthBar = game.add.image(42, 8, "healthBar");
	healthBar.setDepth(Infinity);
	energyBar = game.add.image(42, 34, "energyBar");
	energyBar.setDepth(Infinity);
	specialBar = game.add.image(42, 60, "specialBar");
	specialBar.setDepth(Infinity);
	connection.send("getath");
	tactileGUI.setVisible(true);
}

function start() {
	connection.send("getmyentityid");
	isBindingKeys = true;
	isPlaying = true;
}

function rebrawl() {
	hideTeamMateSpectating();
	isSpectator = false;
	connection.send("getmyentityid");
	connection.send("getentities");
	healthBar.setVisible(true);
	energyBar.setVisible(true);
	specialBar.setVisible(true);
	connection.send("getath");
	isBindingKeys = true;
	isPlaying = true;
	tactileGUI.setVisible(true);
}

function displayMap(pattern) {
	var first = -12 // selon map.png
	for (var i = 0 ; i < pattern.length ; i++)
		for (var j = 0 ; j < pattern[i].length ; j++) {
			var frag = frags.create(j*64-(pattern[i][j]-first)%4*64, i*64-48-Math.floor((pattern[i][j]-first)/4)*96, 'map');
			frag.setOrigin(0,0);
			frag.setDepth(pattern[i][j] > 1 ? (i*64+32) : 0);
			frag.setCrop((pattern[i][j]-first)%4*64,Math.floor((pattern[i][j]-first)/4)*96,64,96);
		}
	//camera.setBounds(0, 0, (pattern.length==0?0:pattern[0].length*64), pattern.length*48);
}

function refreshEntities(entitiesObj) {
	entities.children.iterate(function(entity) {
		var toRemove = true;
		for (var i = 0; i < entitiesObj.length; i++)
			if (entity.id == entitiesObj[i].id)
				toRemove = false;
		if (toRemove) {
			if (entity) entity.stop();
			entities.remove(entity, true, true);
			//console.log("entity removed "+entity.id)
		}
	});
	for (var i = 0; i < entitiesObj.length; i++) {
		//entitiesObj[i].y *= 3/4;
		if (entities.children.get("id", entitiesObj[i].id)) {
			var entity = entities.children.get("id", entitiesObj[i].id);
			entity.refresh(entitiesObj[i].x, entitiesObj[i].y, entitiesObj[i].image, entitiesObj[i].visible, entitiesObj[i].player);
			//console.log("entity edited "+entity);
		} else {
			entities.add(new Entity(game, entitiesObj[i].x, entitiesObj[i].y, entitiesObj[i].image, entitiesObj[i].id, entitiesObj[i].visible, entitiesObj[i].player), true);
			//console.log("entity created "+entity);
		}
	}
	if (camera._follow) {
		healthBar.setPosition(camera._follow.x, camera._follow.y-40-8);
		energyBar.setPosition(camera._follow.x, camera._follow.y-40);
		specialBar.setPosition(camera._follow.x, camera._follow.y-40+8);
	}
	
}

function refreshHealth(newHealth) {
	if (newHealth !== health) {
		var damageInfo = game.add.text(camera._follow.x+Phaser.Math.Between(-48,48), camera._follow.y+Phaser.Math.Between(-48,48), newHealth-health+"♥")
		.setFontFamily("Arial").setColor(newHealth<health?"red":"lime").setFontSize(32).setOrigin(0.5).setDepth(Infinity)
		.setRotation(Phaser.Math.FloatBetween(-0.2, 0.2));
		setTimeout(function() {
				damageInfo.destroy();
			}, 1000);
	}
	health = newHealth;
	let cropWidth = (health*64/healthMax);
	healthBar.setCrop(0, 0, cropWidth, 8);
}

function refreshEnergy(newEnergy) {
	energy = newEnergy
	let cropWidth = (energy*64/energyMax);
	energyBar.setCrop(0, 0, cropWidth, 8);
}

function refreshSpecial(newSpecial) {
	special = newSpecial;
	let cropWidth = (special*64/specialMax);
	specialBar.setCrop(0, 0, cropWidth, 8);
}

function onEffect(data) {
	switch (data.name) {
		case "tracking":
			camera.zoomTo(0.5, 200, true);
			break;
		case "stun":
			camera.shake(camera.shake(data.duration, 0.01));
			break;
	}
	setTimeout(function() {
		switch (data.name) {
			case "tracking":
				camera.zoomTo(1, 200, true);
				break;
		}
	}, data.duration);
}

function hideATH() {
	healthBar.visible = false;
	energyBar.visible = false;
	specialBar.visible = false;
}

function printTabMenu() {
	let teamsEls = [addDiv("tab-title", 1, 1, 98, 8, [addText("tab-title-name", 2, 2, 4, "Équipes", 76, "white", true), addText("tab-title-score", 82, 2, 4, "Scores", 16, "white", true)], "rgba(200,200,200,0.5)", true)];
	for (let i = 0; i < teams.length; i++)
		teamsEls.push(addDiv("tab-team"+i, 1, 11+10*i, 98, 8, [addText("tab-team"+i+"-name", 2, 2, 4, teams[i].name, 76, teams[i].color, true), addText("tab-team"+i+"-score", 82, 2, 4, teams[i].score, 16, teams[i].color, true)], "rgba(200,200,200,0.5)", true));
	addDiv("tab", 200, 100, 400, 400, teamsEls, "rgba(200,200,200,0.8)");
}

function hideTabMenu() {
	remove("tab");
}



//----Spectator mode

function printTeamMateSpectatingMenu(){
	var teamMatesEls = [];
	for (var i = 0; i<teamMates.length; i++){
		teamMatesEls.push(
			addDiv("teammate"+i, i*55, 0, 50, 400, 
				[addText("teammateClass"+i, 0, 0, 4, teamMates[i].name, i*55, "", 50, 400),
				addButton("chooseWhoSpect"+i, 0, 30, 50, 40, spectatorView, [teamMates[i].name], "Suivre ce joueur", 3, "", 50, 400)]
			,"",600,400 )
			);
	}
	addDiv("teammates", 100, 100, 600, 400, teamMatesEls,"white");
	spectatorMenuButton.visible = false;
}

function spectatorView(nom){
	connection.send("follow "+nom);
	connection.send("getfollowingentityid");
	hideTeamMateSpectating();
}

function hideTeamMateSpectating(){
	remove("teammate");
	remove("teammateClass");
	remove("chooseWhoSpect");
	remove("teammates");
	spectatorMenuButton.visible = true;
	
}



//----Gestion des entrées clavier, souris et tactile

function switchInputMode() {
	isTactile = !isTactile;
	if (isTactile) {
		joystick.setVisible(true);
		joystickBack.setVisible(true);
		specialButton.setVisible(true);
	} else {
		joystick.followCursor = false;
		joystick.setVisible(false);
		joystickBack.setVisible(false);
		specialButton.setVisible(false);
		specialLoaded.setVisible(false);
		nextIsSpecial = false;
	}
}

function onKeyDown(e) {
	if (!isBindingKeys) return;
	switch (e.key) {
		case 'z':
			keys.up = true;
			break;
		case 'q':
			keys.left = true;
			break;
		case 's':
			keys.down = true;
			break;
		case 'd':
			keys.right = true;
			break;
		case 'Tab':
			if (!exists("tab")) connection.send("getteams");
			printTabMenu();
			break;
		default:
			return;
	}
	e.preventDefault();
	sendMove(getAngleInRadians(getKeyboardVector()));
}

function onKeyUp(e) {
	switch (e.key) {
		case 'z':
			keys.up = false;
			break;
		case 'q':
			keys.left = false;
			break;
		case 's':
			keys.down = false;
			break;
		case 'd':
			keys.right = false;
			break;
		case 'Tab':
			hideTabMenu();
			break;
		default:
			return;
	}
	if (!isBindingKeys) return;
	e.preventDefault();
	sendMove(getAngleInRadians(getKeyboardVector()));
}

function getAngleInRadians(vector) {
	if (vector.x == 0 && vector.y == 0) return undefined;
	return Math.atan2(vector.y, vector.x);
}

function getKeyboardVector() {
	var v = {x:0, y:0};
	if (keys.up) v.y--;
	if (keys.down) v.y++;
	if (keys.right) v.x++;
	if (keys.left) v.x--;
	return v;
}

function sendMove(angle) {
	if (angle == lastMove) return;
	else lastMove = angle;
	if (angle == undefined) connection.send("stopmove");
	else connection.send("move " + angle/Math.PI);
}

function onClick(pointer) {
	if (isTactile) {
		if (pointer.x < 200 && pointer.y > 400) { // joystick
			joystick.setPosition(pointer.x, pointer.y);
			joystickBack.setPosition(pointer.x, pointer.y);
			joystick.followCursor = pointer;
		} else {
			if (!isBindingKeys) return;
			if (!nextIsSpecial)
				sendClick(pointer.x, pointer.y);
			else {
				sendLeft(pointer.x, pointer.y);
				nextIsSpecial = false;
				specialLaoded.setVisible(false);
			}
		}
	} else {
		if (!isBindingKeys) return;
		if (pointer.buttons == 1)
			sendClick(pointer.x, pointer.y);
		else if (pointer.buttons == 2)
			sendLeft(pointer.x, pointer.y);
	}
}

function unClick(pointer) {
	if (isTactile) {
		if (joystick.followCursor && pointer.id==joystick.followCursor.id) {
			joystick.followCursor = false;
			joystick.setPosition(joystickBack.x, joystickBack.y);
			if (isBindingKeys) sendMove(undefined);
		}
	}
}

function onSpecialButton(pointer, a, b, propa) {
	if (!isBindingKeys) return;
	nextIsSpecial = !nextIsSpecial && special>=specialMax-20;
	specialLoaded.setVisible(nextIsSpecial);
	propa.stopPropagation();
}

function sendClick(x, y) {
	connection.send("attack " + getAngleInRadians({x: x/camera.zoom-camera._follow.x+camera.worldView.x, y:(y/camera.zoom-camera._follow.y+camera.worldView.y)*4/3})/Math.PI);
}

function sendLeft(x, y) {
	connection.send("specialattack " + getAngleInRadians({x: x/camera.zoom-camera._follow.x+camera.worldView.x, y:(y/camera.zoom-camera._follow.y+camera.worldView.y)*4/3})/Math.PI);
}



//----Autres

function switchFullscreen() {
	if (game.scale.isFullscreen) {
		game.scale.stopFullscreen();
	} else {
		game.scale.startFullscreen();
	}
}



//----Entity class

class Entity extends Phaser.GameObjects.Sprite {
	
	constructor (scene, x, y, image, id, visible, player) {
		super(scene, x, y);
		
		if (!image.name) image.name = "";
		if (!image.suffix) image.suffix = "";
		if (!image.rotation) image.rotation = 0;
		if (!image.flip) image.flip = false;
		this.setDepth(image.onGround ? 0 : y);
		this.image = image;
		this.id = id;
		this.setTexture(image.name+image.suffix);
		this.setRotation(image.rotation*Math.PI);
		this.setFlipY(image.flip);
		if (!visible) this.setAlpha(0.2);
		this.isPlayable = (image.name=="guerrier"||image.name=="archer"||image.name=="golem"||image.name=="assassin"||image.name=="mage"||image.name=="necromancien"||image.name=="alchimiste");
		this.isMoving = false;
		if (this.isPlayable) this.moveSound = game.sound.add('run');
		if (player && id != myEntityId) this.name = game.add.text(x, y-48, player.name+"\n"+player.team.name)
			.setAlign("center").setFontFamily("Arial").setColor("white").setFontSize(16).setOrigin(0.5).setDepth(y);
	}
	
	refresh(x, y, image, visible, player) {
		this.isMoving = (this.x != x || this.y != y);
		this.setPosition(x, y);
		this.setDepth(image.onGround ? 0 : y);
		this.setTexture(image.name+image.suffix);
		this.setRotation(image.rotation*Math.PI);
		this.setFlipY(image.flip);
		this.setAlpha(visible ? 1 : 0.2);
		if (this.moveSound) {
			this.moveSound.setVolume((1-(Math.sqrt((x-camera.worldView.x-400)*(x-camera.worldView.x-400)+(y-camera.worldView.y-300)*(y-camera.worldView.y-300)))/500)/4);
			//console.log((1-(Math.sqrt((x-camera.worldView.x-400)*(x-camera.worldView.x-400)+(y-camera.worldView.y-300)*(y-camera.worldView.y-300)))/500)/4);
			if (this.isMoving && !this.moveSound.isPlaying) {
				this.moveSound.resume();
				if (!this.moveSound.isPlaying) this.moveSound.play();
			}
			if (!this.isMoving && this.moveSound.isPlaying) this.moveSound.pause();
		}
		if (this.name) this.name.setPosition(x, y-48).setDepth(y);
	}
	
	stop() {
		if (this.moveSound) this.moveSound.stop();
		if (this.name) this.name.destroy();
	}
	
	preUpdate(time, delta){
		super.preUpdate(time, delta);
	}
	
}

		</script>
	</body>
</html>
